import os
import logging
import io
from datetime import datetime, timedelta
from typing import Dict, List
import pytz
import json
import pandas as pd

from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InputFile
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
    ConversationHandler,
    JobQueue
)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
TELEGRAM_BOT_TOKEN = "8009687103:AAHTSA2qRElH1X6yOb1-Yr6rfQ_X5VqaPsA"
ADMIN_CHAT_ID = None

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è ConversationHandler
GET_FULL_NAME, GET_POSITION, SELECT_DEPARTMENT, GET_DEPARTMENT, SELECT_CHECK_PERIOD, GET_CHECK_DATE, GET_PROTOCOL_NUMBER = range(7)
EDIT_DEPARTMENT, EDIT_EMPLOYEE, EDIT_OPTION, EDIT_DATE, EDIT_PERIOD = range(5)
DELETE_DEPARTMENT, DELETE_EMPLOYEE = range(2)

# –ü–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å –ø—Ä–æ–≤–µ—Ä–∫–∏
CHECK_PERIOD_1_YEAR = 1
CHECK_PERIOD_3_YEARS = 3

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã
main_keyboard = ReplyKeyboardMarkup(
    [
        ['‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞', 'üìã –°–ø–∏—Å–æ–∫ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤'],
        ['‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ', '‚ùå –£–¥–∞–ª–∏—Ç—å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞'],
        ['‚ö†Ô∏è –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã—Ö', 'üì• –≠–∫—Å–ø–æ—Ä—Ç –≤ —Ñ–∞–π–ª'],
        ['üë®‚Äçüíª –ù–∞–∑–Ω–∞—á–∏—Ç—å –∞–¥–º–∏–Ω–∞']
    ],
    resize_keyboard=True,
    one_time_keyboard=False
)

cancel_keyboard = ReplyKeyboardMarkup(
    [['‚ùå –û—Ç–º–µ–Ω–∏—Ç—å']],
    resize_keyboard=True
)

period_keyboard = ReplyKeyboardMarkup(
    [['1 —Ä–∞–∑ –≤ –≥–æ–¥', '1 —Ä–∞–∑ –≤ 3 –≥–æ–¥–∞'], ['‚ùå –û—Ç–º–µ–Ω–∏—Ç—å']],
    resize_keyboard=True
)

edit_keyboard = ReplyKeyboardMarkup(
    [['‚úèÔ∏è –î–∞—Ç–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏', '‚úèÔ∏è –ü–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å'], ['‚ùå –û—Ç–º–µ–Ω–∏—Ç—å']],
    resize_keyboard=True
)

class Employee:
    def __init__(self, full_name: str, position: str, department: str, last_check_date: datetime, 
                 protocol_number: str = None, check_period: int = CHECK_PERIOD_3_YEARS):
        self.full_name = full_name
        self.position = position
        self.department = department
        self.last_check_date = last_check_date
        self.protocol_number = protocol_number
        self.check_period = check_period

    def to_dict(self) -> Dict:
        return {
            'full_name': self.full_name,
            'position': self.position,
            'department': self.department,
            'last_check_date': self.last_check_date.isoformat(),
            'protocol_number': self.protocol_number,
            'check_period': self.check_period
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'Employee':
        return cls(
            full_name=data['full_name'],
            position=data['position'],
            department=data.get('department', '–ù–µ —É–∫–∞–∑–∞–Ω–æ'),
            last_check_date=datetime.fromisoformat(data['last_check_date']),
            protocol_number=data.get('protocol_number'),
            check_period=data.get('check_period', CHECK_PERIOD_3_YEARS)
        )

    def get_next_check_date(self) -> datetime:
        return self.last_check_date.replace(tzinfo=pytz.utc) + timedelta(days=365 * self.check_period)

class Storage:
    def __init__(self, data_file: str = 'employees.json'):
        self.data_file = data_file
        self.employees: List[Employee] = []
        self._load_data()

    def _save_data(self):
        with open(self.data_file, 'w', encoding='utf-8') as f:
            json.dump([emp.to_dict() for emp in self.employees], f, indent=4, ensure_ascii=False)

    def _load_data(self):
        if os.path.exists(self.data_file):
            with open(self.data_file, 'r', encoding='utf-8') as f:
                try:
                    data = json.load(f)
                    self.employees = [Employee.from_dict(d) for d in data]
                except (json.JSONDecodeError, KeyError):
                    self.employees = []

    def add_employee(self, employee: Employee):
        self.employees.append(employee)
        self._save_data()

    def get_employees(self) -> List[Employee]:
        return self.employees

    def get_departments(self) -> List[str]:
        departments = list(set(emp.department for emp in self.employees))
        return sorted(departments)

    def find_employee_by_name(self, full_name: str) -> Employee:
        for emp in self.employees:
            if emp.full_name.lower() == full_name.lower():
                return emp
        return None

    def update_employee_check_date(self, full_name: str, new_date: datetime, protocol_number: str = None):
        for emp in self.employees:
            if emp.full_name.lower() == full_name.lower():
                emp.last_check_date = new_date
                if protocol_number:
                    emp.protocol_number = protocol_number
                self._save_data()
                return True
        return False

    def update_employee_check_period(self, full_name: str, new_period: int):
        for emp in self.employees:
            if emp.full_name.lower() == full_name.lower():
                emp.check_period = new_period
                self._save_data()
                return True
        return False

    def delete_employee(self, full_name: str):
        initial_count = len(self.employees)
        self.employees = [emp for emp in self.employees if emp.full_name.lower() != full_name.lower()]
        if len(self.employees) < initial_count:
            self._save_data()
            return True
        return False

    def find_overdue_employees(self, department: str = None) -> List[Employee]:
        now = datetime.now(pytz.utc)
        employees = self.employees

        if department:
            employees = [emp for emp in employees if emp.department.lower() == department.lower()]

        return [
            emp for emp in employees
            if emp.get_next_check_date() <= now
        ]

    def find_upcoming_checks(self, days_before: int = 15, department: str = None) -> List[Employee]:
        now = datetime.now(pytz.utc)
        employees = self.employees

        if department:
            employees = [emp for emp in employees if emp.department.lower() == department.lower()]

        result = []
        for emp in employees:
            check_anniversary = emp.get_next_check_date()
            days_until_check = (check_anniversary - now).days
            if 0 <= days_until_check <= days_before:
                result.append(emp)
        return result

storage = Storage()

# –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(
        "üî∞ <b>–ë–æ—Ç —É—á–µ—Ç–∞ –ø—Ä–æ–≤–µ—Ä–æ–∫ –∑–Ω–∞–Ω–∏–π –ø–æ –æ—Ö—Ä–∞–Ω–µ —Ç—Ä—É–¥–∞</b>\n\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è:",
        reply_markup=main_keyboard,
        parse_mode='HTML'
    )

async def set_admin_chat(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    global ADMIN_CHAT_ID
    ADMIN_CHAT_ID = update.effective_chat.id
    with open('config.json', 'w') as f:
        json.dump({'admin_chat_id': ADMIN_CHAT_ID}, f)
    await update.message.reply_text(
        f"‚úÖ –ß–∞—Ç –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω (ID: {ADMIN_CHAT_ID})",
        reply_markup=main_keyboard
    )

# –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞
async def add_employee_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text(
        "üìù –í–≤–µ–¥–∏—Ç–µ –§–ò–û —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞:",
        reply_markup=cancel_keyboard
    )
    return GET_FULL_NAME

async def get_full_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    context.user_data['full_name'] = update.message.text
    await update.message.reply_text(
        "üíº –í–≤–µ–¥–∏—Ç–µ –¥–æ–ª–∂–Ω–æ—Å—Ç—å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞:",
        reply_markup=cancel_keyboard
    )
    return GET_POSITION

async def get_position(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    context.user_data['position'] = update.message.text
    
    departments = storage.get_departments()
    if departments:
        departments_keyboard = ReplyKeyboardMarkup(
            [[dept] for dept in departments] + [['‚ûï –ù–æ–≤–æ–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ'], ['‚ùå –û—Ç–º–µ–Ω–∏—Ç—å']],
            resize_keyboard=True,
            one_time_keyboard=True
        )
        await update.message.reply_text(
            "üè¢ –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –∏–ª–∏ —Å–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤–æ–µ:",
            reply_markup=departments_keyboard
        )
        return SELECT_DEPARTMENT
    else:
        await update.message.reply_text(
            "üè¢ –í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è:",
            reply_markup=cancel_keyboard
        )
        return GET_DEPARTMENT

async def select_department(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    if update.message.text == '‚ûï –ù–æ–≤–æ–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ':
        await update.message.reply_text(
            "üè¢ –í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è:",
            reply_markup=cancel_keyboard
        )
        return GET_DEPARTMENT
    
    context.user_data['department'] = update.message.text
    await update.message.reply_text(
        "üîÑ –í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–Ω–∞–Ω–∏–π:",
        reply_markup=period_keyboard
    )
    return SELECT_CHECK_PERIOD

async def get_department(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    context.user_data['department'] = update.message.text
    await update.message.reply_text(
        "üîÑ –í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–Ω–∞–Ω–∏–π:",
        reply_markup=period_keyboard
    )
    return SELECT_CHECK_PERIOD

async def select_check_period(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    if update.message.text == '1 —Ä–∞–∑ –≤ –≥–æ–¥':
        context.user_data['check_period'] = CHECK_PERIOD_1_YEAR
    elif update.message.text == '1 —Ä–∞–∑ –≤ 3 –≥–æ–¥–∞':
        context.user_data['check_period'] = CHECK_PERIOD_3_YEARS
    else:
        await update.message.reply_text(
            "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤:",
            reply_markup=period_keyboard
        )
        return SELECT_CHECK_PERIOD
    
    await update.message.reply_text(
        "üìÖ –í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –ø–æ—Å–ª–µ–¥–Ω–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ (–î–î.–ú–ú.–ì–ì–ì–ì):",
        reply_markup=cancel_keyboard
    )
    return GET_CHECK_DATE

async def get_check_date(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    try:
        date_str = update.message.text
        check_date = datetime.strptime(date_str, "%d.%m.%Y").replace(tzinfo=pytz.utc)
        context.user_data['last_check_date'] = check_date
        await update.message.reply_text(
            "üî¢ –í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–Ω–∞–Ω–∏–π (–µ—Å–ª–∏ –µ—Å—Ç—å, –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /skip):",
            reply_markup=cancel_keyboard
        )
        return GET_PROTOCOL_NUMBER
    except ValueError:
        await update.message.reply_text(
            "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì:",
            reply_markup=cancel_keyboard
        )
        return GET_CHECK_DATE

async def get_protocol_number(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    protocol_number = update.message.text
    employee = Employee(
        full_name=context.user_data['full_name'],
        position=context.user_data['position'],
        department=context.user_data['department'],
        last_check_date=context.user_data['last_check_date'],
        protocol_number=protocol_number if protocol_number != '/skip' else None,
        check_period=context.user_data.get('check_period', CHECK_PERIOD_3_YEARS)
    )

    storage.add_employee(employee)

    period_text = "1 —Ä–∞–∑ –≤ –≥–æ–¥" if employee.check_period == CHECK_PERIOD_1_YEAR else "1 —Ä–∞–∑ –≤ 3 –≥–æ–¥–∞"
    next_check = employee.get_next_check_date().strftime('%d.%m.%Y')

    message = (
        f"‚úÖ –°–æ—Ç—Ä—É–¥–Ω–∏–∫ —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω:\n\n"
        f"<b>–§–ò–û:</b> {employee.full_name}\n"
        f"<b>–î–æ–ª–∂–Ω–æ—Å—Ç—å:</b> {employee.position}\n"
        f"<b>–ü–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ:</b> {employee.department}\n"
        f"<b>–ü–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å –ø—Ä–æ–≤–µ—Ä–∫–∏:</b> {period_text}\n"
        f"<b>–î–∞—Ç–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏:</b> {employee.last_check_date.strftime('%d.%m.%Y')}\n"
        f"<b>–°–ª–µ–¥—É—é—â–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞:</b> {next_check}\n"
    )

    if employee.protocol_number:
        message += f"<b>‚Ññ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞:</b> {employee.protocol_number}\n"

    await update.message.reply_text(
        message,
        reply_markup=main_keyboard,
        parse_mode='HTML'
    )
    context.user_data.clear()
    return ConversationHandler.END

async def skip_protocol_number(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    employee = Employee(
        full_name=context.user_data['full_name'],
        position=context.user_data['position'],
        department=context.user_data['department'],
        last_check_date=context.user_data['last_check_date'],
        protocol_number=None,
        check_period=context.user_data.get('check_period', CHECK_PERIOD_3_YEARS)
    )

    storage.add_employee(employee)

    period_text = "1 —Ä–∞–∑ –≤ –≥–æ–¥" if employee.check_period == CHECK_PERIOD_1_YEAR else "1 —Ä–∞–∑ –≤ 3 –≥–æ–¥–∞"
    next_check = employee.get_next_check_date().strftime('%d.%m.%Y')

    await update.message.reply_text(
        f"‚úÖ –°–æ—Ç—Ä—É–¥–Ω–∏–∫ —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω:\n\n"
        f"<b>–§–ò–û:</b> {employee.full_name}\n"
        f"<b>–î–æ–ª–∂–Ω–æ—Å—Ç—å:</b> {employee.position}\n"
        f"<b>–ü–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ:</b> {employee.department}\n"
        f"<b>–ü–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å –ø—Ä–æ–≤–µ—Ä–∫–∏:</b> {period_text}\n"
        f"<b>–î–∞—Ç–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏:</b> {employee.last_check_date.strftime('%d.%m.%Y')}\n"
        f"<b>–°–ª–µ–¥—É—é—â–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞:</b> {next_check}\n"
        f"<b>‚Ññ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞:</b> –Ω–µ —É–∫–∞–∑–∞–Ω",
        reply_markup=main_keyboard,
        parse_mode='HTML'
    )
    context.user_data.clear()
    return ConversationHandler.END

# –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞
async def edit_employee_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    departments = storage.get_departments()

    if not departments:
        await update.message.reply_text(
            "üì≠ –°–ø–∏—Å–æ–∫ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ –ø—É—Å—Ç.",
            reply_markup=main_keyboard
        )
        return ConversationHandler.END

    departments_keyboard = ReplyKeyboardMarkup(
        [[dept] for dept in departments] + [['‚ùå –û—Ç–º–µ–Ω–∏—Ç—å']],
        resize_keyboard=True,
        one_time_keyboard=True
    )

    await update.message.reply_text(
        "üè¢ –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ, –≤ –∫–æ—Ç–æ—Ä–æ–º –Ω—É–∂–Ω–æ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞:",
        reply_markup=departments_keyboard
    )
    return EDIT_DEPARTMENT

async def select_employee_to_edit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    department = update.message.text
    employees = [emp for emp in storage.get_employees() if emp.department == department]

    if not employees:
        await update.message.reply_text(
            f"üì≠ –í –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–∏ '{department}' –Ω–µ—Ç —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤.",
            reply_markup=main_keyboard
        )
        return ConversationHandler.END

    context.user_data['edit_department'] = department

    employee_keyboard = ReplyKeyboardMarkup(
        [[emp.full_name] for emp in employees] + [['‚ùå –û—Ç–º–µ–Ω–∏—Ç—å']],
        resize_keyboard=True,
        one_time_keyboard=True
    )

    await update.message.reply_text(
        f"üë• –í—ã–±–µ—Ä–∏—Ç–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞ –∏–∑ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è '{department}' –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:",
        reply_markup=employee_keyboard
    )
    return EDIT_EMPLOYEE

async def select_edit_option(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    full_name = update.message.text
    department = context.user_data.get('edit_department')

    employee = next((emp for emp in storage.get_employees() 
                    if emp.full_name.lower() == full_name.lower() 
                    and emp.department == department), None)

    if not employee:
        await update.message.reply_text(
            f"‚ùå –°–æ—Ç—Ä—É–¥–Ω–∏–∫ '{full_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–∏ '{department}'. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞:",
            reply_markup=cancel_keyboard
        )
        return EDIT_EMPLOYEE

    context.user_data['edit_employee'] = full_name
    await update.message.reply_text(
        "‚úèÔ∏è –í—ã–±–µ—Ä–∏—Ç–µ, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å:",
        reply_markup=edit_keyboard
    )
    return EDIT_OPTION

async def edit_employee_option(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    if update.message.text == '‚úèÔ∏è –ü–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å':
        await update.message.reply_text(
            "üîÑ –í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–≤—É—é –ø–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å –ø—Ä–æ–≤–µ—Ä–∫–∏:",
            reply_markup=period_keyboard
        )
        return EDIT_PERIOD
    
    if update.message.text == '‚úèÔ∏è –î–∞—Ç–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏':
        full_name = context.user_data['edit_employee']
        employee = storage.find_employee_by_name(full_name)
        
        protocol_info = f" (‚Ññ {employee.protocol_number})" if employee.protocol_number else ""
        await update.message.reply_text(
            f"üìÖ –¢–µ–∫—É—â–∞—è –¥–∞—Ç–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏: {employee.last_check_date.strftime('%d.%m.%Y')}{protocol_info}\n"
            "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—É—é –¥–∞—Ç—É –ø—Ä–æ–≤–µ—Ä–∫–∏ (–î–î.–ú–ú.–ì–ì–ì–ì) –∏ –Ω–æ–º–µ—Ä –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é (–Ω–∞–ø—Ä–∏–º–µ—Ä: 01.01.2023, –ü–ö-123):",
            reply_markup=cancel_keyboard
        )
        return EDIT_DATE
    
    await update.message.reply_text(
        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:",
        reply_markup=edit_keyboard
    )
    return EDIT_OPTION

async def update_employee_date(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    try:
        input_text = update.message.text
        parts = [part.strip() for part in input_text.split(',', 1)]

        date_str = parts[0]
        protocol_number = parts[1] if len(parts) > 1 else None

        new_date = datetime.strptime(date_str, "%d.%m.%Y").replace(tzinfo=pytz.utc)
        full_name = context.user_data['edit_employee']

        if storage.update_employee_check_date(full_name, new_date, protocol_number):
            employee = storage.find_employee_by_name(full_name)
            next_check = employee.get_next_check_date().strftime('%d.%m.%Y')
            
            message = (
                f"‚úÖ –î–∞—Ç–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è <b>{full_name}</b> –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –Ω–∞ <b>{new_date.strftime('%d.%m.%Y')}</b>\n"
                f"–°–ª–µ–¥—É—é—â–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: <b>{next_check}</b>"
            )
            if protocol_number:
                message += f"\n–ù–æ–º–µ—Ä –ø—Ä–æ—Ç–æ–∫–æ–ª–∞: <b>{protocol_number}</b>"

            await update.message.reply_text(
                message,
                reply_markup=main_keyboard,
                parse_mode='HTML'
            )
        else:
            await update.message.reply_text(
                "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –¥–∞—Ç—ã –ø—Ä–æ–≤–µ—Ä–∫–∏.",
                reply_markup=main_keyboard
            )

        context.user_data.clear()
        return ConversationHandler.END
    except ValueError:
        await update.message.reply_text(
            "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì –∏ –Ω–æ–º–µ—Ä –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é:",
            reply_markup=cancel_keyboard
        )
        return EDIT_DATE

async def update_employee_period(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    if update.message.text == '1 —Ä–∞–∑ –≤ –≥–æ–¥':
        new_period = CHECK_PERIOD_1_YEAR
    elif update.message.text == '1 —Ä–∞–∑ –≤ 3 –≥–æ–¥–∞':
        new_period = CHECK_PERIOD_3_YEARS
    else:
        await update.message.reply_text(
            "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤:",
            reply_markup=period_keyboard
        )
        return EDIT_PERIOD
    
    full_name = context.user_data['edit_employee']
    
    if storage.update_employee_check_period(full_name, new_period):
        employee = storage.find_employee_by_name(full_name)
        next_check = employee.get_next_check_date().strftime('%d.%m.%Y')
        period_text = "1 —Ä–∞–∑ –≤ –≥–æ–¥" if new_period == CHECK_PERIOD_1_YEAR else "1 —Ä–∞–∑ –≤ 3 –≥–æ–¥–∞"
        
        await update.message.reply_text(
            f"‚úÖ –ü–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è <b>{full_name}</b> –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ <b>{period_text}</b>\n"
            f"–°–ª–µ–¥—É—é—â–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: <b>{next_check}</b>",
            reply_markup=main_keyboard,
            parse_mode='HTML'
        )
    else:
        await update.message.reply_text(
            "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏.",
            reply_markup=main_keyboard
        )

    context.user_data.clear()
    return ConversationHandler.END

# –£–¥–∞–ª–µ–Ω–∏–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞
async def delete_employee_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    departments = storage.get_departments()

    if not departments:
        await update.message.reply_text(
            "üì≠ –°–ø–∏—Å–æ–∫ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ –ø—É—Å—Ç.",
            reply_markup=main_keyboard
        )
        return ConversationHandler.END

    departments_keyboard = ReplyKeyboardMarkup(
        [[dept] for dept in departments] + [['‚ùå –û—Ç–º–µ–Ω–∏—Ç—å']],
        resize_keyboard=True,
        one_time_keyboard=True
    )

    await update.message.reply_text(
        "üè¢ –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ, –∏–∑ –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞:",
        reply_markup=departments_keyboard
    )
    return DELETE_DEPARTMENT

async def select_employee_to_delete(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    department = update.message.text
    employees = [emp for emp in storage.get_employees() if emp.department == department]

    if not employees:
        await update.message.reply_text(
            f"üì≠ –í –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–∏ '{department}' –Ω–µ—Ç —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤.",
            reply_markup=main_keyboard
        )
        return ConversationHandler.END

    context.user_data['delete_department'] = department

    employee_keyboard = ReplyKeyboardMarkup(
        [[emp.full_name] for emp in employees] + [['‚ùå –û—Ç–º–µ–Ω–∏—Ç—å']],
        resize_keyboard=True,
        one_time_keyboard=True
    )

    await update.message.reply_text(
        f"üë• –í—ã–±–µ—Ä–∏—Ç–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞ –∏–∑ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è '{department}' –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:",
        reply_markup=employee_keyboard
    )
    return DELETE_EMPLOYEE

async def delete_employee_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    full_name = update.message.text
    department = context.user_data.get('delete_department')

    employee = next((emp for emp in storage.get_employees() 
                    if emp.full_name.lower() == full_name.lower() 
                    and emp.department == department), None)

    if not employee:
        await update.message.reply_text(
            f"‚ùå –°–æ—Ç—Ä—É–¥–Ω–∏–∫ '{full_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–∏ '{department}'. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞:",
            reply_markup=cancel_keyboard
        )
        return DELETE_EMPLOYEE

    if storage.delete_employee(full_name):
        await update.message.reply_text(
            f"‚úÖ –°–æ—Ç—Ä—É–¥–Ω–∏–∫ <b>{full_name}</b> —É–¥–∞–ª–µ–Ω –∏–∑ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è <b>{department}</b>.",
            reply_markup=main_keyboard,
            parse_mode='HTML'
        )
    else:
        await update.message.reply_text(
            "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞.",
            reply_markup=main_keyboard
        )

    context.user_data.clear()
    return ConversationHandler.END

# –ü—Ä–æ—Å–º–æ—Ç—Ä —Å–ø–∏—Å–∫–∞
async def list_employees(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    departments = storage.get_departments()

    if not departments:
        await update.message.reply_text(
            "üì≠ –°–ø–∏—Å–æ–∫ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ –ø—É—Å—Ç.",
            reply_markup=main_keyboard
        )
        return

    departments_keyboard = ReplyKeyboardMarkup(
        [[dept] for dept in departments] + [['–í—Å–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è'], ['‚ùå –û—Ç–º–µ–Ω–∏—Ç—å']],
        resize_keyboard=True
    )

    await update.message.reply_text(
        "üè¢ –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞:",
        reply_markup=departments_keyboard
    )

    context.user_data['action'] = 'list_employees'
    return 'waiting_department_selection'

async def show_employees_by_department(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    department = update.message.text
    employees = storage.get_employees()

    if department.lower() != '–≤—Å–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è':
        employees = [emp for emp in employees if emp.department.lower() == department.lower()]

    if not employees:
        await update.message.reply_text(
            f"üì≠ –í –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–∏ '{department}' –Ω–µ—Ç —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤.",
            reply_markup=main_keyboard
        )
        return

    chunk_size = 10
    for i in range(0, len(employees), chunk_size):
        chunk = employees[i:i + chunk_size]
        message = f"üìã <b>–°–ø–∏—Å–æ–∫ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ ({department}):</b>\n\n" if i == 0 else ""
        for emp in chunk:
            next_check = emp.get_next_check_date()
            period_text = "1 —Ä–∞–∑ –≤ –≥–æ–¥" if emp.check_period == CHECK_PERIOD_1_YEAR else "1 —Ä–∞–∑ –≤ 3 –≥–æ–¥–∞"
            protocol_info = f"\n  <b>‚Ññ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞:</b> {emp.protocol_number}" if emp.protocol_number else ""
            message += (
                f"<b>‚Ä¢ {emp.full_name}</b>\n"
                f"  –î–æ–ª–∂–Ω–æ—Å—Ç—å: {emp.position}\n"
                f"  –ü–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ: {emp.department}\n"
                f"  –ü–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å: {period_text}\n"
                f"  –ü–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–æ–≤–µ—Ä–∫–∞: {emp.last_check_date.strftime('%d.%m.%Y')}\n"
                f"  –°–ª–µ–¥—É—é—â–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: {next_check.strftime('%d.%m.%Y')}"
                f"{protocol_info}\n\n"
            )
        await update.message.reply_text(
            message,
            reply_markup=main_keyboard if i + chunk_size >= len(employees) else None,
            parse_mode='HTML'
        )

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã—Ö
async def check_overdue(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    departments = storage.get_departments()

    if not departments:
        await update.message.reply_text(
            "üì≠ –°–ø–∏—Å–æ–∫ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ –ø—É—Å—Ç.",
            reply_markup=main_keyboard
        )
        return

    departments_keyboard = ReplyKeyboardMarkup(
        [[dept] for dept in departments] + [['–í—Å–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è'], ['‚ùå –û—Ç–º–µ–Ω–∏—Ç—å']],
        resize_keyboard=True
    )

    await update.message.reply_text(
        "üè¢ –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏:",
        reply_markup=departments_keyboard
    )

    context.user_data['action'] = 'check_overdue'
    return 'waiting_department_selection'

async def show_overdue_by_department(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    department = update.message.text
    overdue = storage.find_overdue_employees(department if department.lower() != '–≤—Å–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è' else None)

    if not overdue:
        await update.message.reply_text(
            f"‚úÖ –í –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–∏ '{department}' –Ω–µ—Ç —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ —Å –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π.",
            reply_markup=main_keyboard
        )
        return

    message = f"‚ö†Ô∏è <b>–ü—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ ({department}):</b>\n\n"
    for emp in overdue:
        period_text = "1 —Ä–∞–∑ –≤ –≥–æ–¥" if emp.check_period == CHECK_PERIOD_1_YEAR else "1 —Ä–∞–∑ –≤ 3 –≥–æ–¥–∞"
        protocol_info = f"\n  <b>‚Ññ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞:</b> {emp.protocol_number}" if emp.protocol_number else ""
        message += (
            f"<b>‚Ä¢ {emp.full_name}</b> ({emp.position})\n"
            f"  –ü–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ: {emp.department}\n"
            f"  –ü–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å: {period_text}\n"
            f"  –ü–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–æ–≤–µ—Ä–∫–∞: {emp.last_check_date.strftime('%d.%m.%Y')}"
            f"{protocol_info}\n\n"
        )
    await update.message.reply_text(
        message,
        reply_markup=main_keyboard,
        parse_mode='HTML'
    )

# –≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö
async def export_data(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    departments = storage.get_departments()

    if not departments:
        await update.message.reply_text(
            "üì≠ –°–ø–∏—Å–æ–∫ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ –ø—É—Å—Ç",
            reply_markup=main_keyboard
        )
        return

    departments_keyboard = ReplyKeyboardMarkup(
        [[dept] for dept in departments] + [['–í—Å–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è'], ['‚ùå –û—Ç–º–µ–Ω–∏—Ç—å']],
        resize_keyboard=True
    )

    await update.message.reply_text(
        "üè¢ –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞:",
        reply_markup=departments_keyboard
    )

    context.user_data['action'] = 'export_data'
    return 'waiting_department_selection'

async def export_data_by_department(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    department = update.message.text
    employees = storage.get_employees()

    if department.lower() != '–≤—Å–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è':
        employees = [emp for emp in employees if emp.department.lower() == department.lower()]

    if not employees:
        await update.message.reply_text(
            f"üì≠ –í –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–∏ '{department}' –Ω–µ—Ç —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤.",
            reply_markup=main_keyboard
        )
        return

    data = {
        '–§–ò–û': [],
        '–î–æ–ª–∂–Ω–æ—Å—Ç—å': [],
        '–ü–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ': [],
        '–ü–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å': [],
        '–î–∞—Ç–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏': [],
        '‚Ññ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞': [],
        '–î–∞—Ç–∞ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏': []
    }

    for emp in employees:
        data['–§–ò–û'].append(emp.full_name)
        data['–î–æ–ª–∂–Ω–æ—Å—Ç—å'].append(emp.position)
        data['–ü–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ'].append(emp.department)
        data['–ü–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å'].append("1 —Ä–∞–∑ –≤ –≥–æ–¥" if emp.check_period == CHECK_PERIOD_1_YEAR else "1 —Ä–∞–∑ –≤ 3 –≥–æ–¥–∞")
        data['–î–∞—Ç–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏'].append(emp.last_check_date.strftime('%d.%m.%Y'))
        data['‚Ññ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞'].append(emp.protocol_number or '–Ω–µ —É–∫–∞–∑–∞–Ω')
        data['–î–∞—Ç–∞ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏'].append(emp.get_next_check_date().strftime('%d.%m.%Y'))

    df = pd.DataFrame(data)

    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        df.to_excel(writer, index=False, sheet_name='–°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏')
        writer.close()

    output.seek(0)
    await update.message.reply_document(
        document=InputFile(output, filename=f'—Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∏_{department}.xlsx'),
        caption=f"üì• <b>–≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ ({department})</b>",
        reply_markup=main_keyboard,
        parse_mode='HTML'
    )

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è
async def handle_department_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if update.message.text == '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å':
        return await cancel(update, context)
    
    action = context.user_data.get('action')

    if action == 'list_employees':
        await show_employees_by_department(update, context)
    elif action == 'check_overdue':
        await show_overdue_by_department(update, context)
    elif action == 'export_data':
        await export_data_by_department(update, context)

    context.user_data.clear()
    return ConversationHandler.END

# –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
async def send_overdue_notifications(context: ContextTypes.DEFAULT_TYPE) -> None:
    if not ADMIN_CHAT_ID:
        return

    departments = storage.get_departments()
    if not departments:
        return

    for department in departments:
        overdue = storage.find_overdue_employees(department)
        if not overdue:
            continue

        message = f"üî¥ <b>–ü—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–Ω–∞–Ω–∏–π ({department}):</b>\n\n"
        for emp in overdue:
            period_text = "1 —Ä–∞–∑ –≤ –≥–æ–¥" if emp.check_period == CHECK_PERIOD_1_YEAR else "1 —Ä–∞–∑ –≤ 3 –≥–æ–¥–∞"
            protocol_info = f"\n  <b>‚Ññ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞:</b> {emp.protocol_number}" if emp.protocol_number else ""
            message += (
                f"‚Ä¢ <b>{emp.full_name}</b> ({emp.position})\n"
                f"  –ü–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å: {period_text}\n"
                f"  –ü–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–æ–≤–µ—Ä–∫–∞: {emp.last_check_date.strftime('%d.%m.%Y')}"
                f"{protocol_info}\n\n"
            )
        await context.bot.send_message(
            chat_id=ADMIN_CHAT_ID,
            text=message,
            parse_mode='HTML'
        )

async def send_upcoming_notifications(context: ContextTypes.DEFAULT_TYPE) -> None:
    if not ADMIN_CHAT_ID:
        return

    departments = storage.get_departments()
    if not departments:
        return

    for department in departments:
        upcoming = storage.find_upcoming_checks(department=department)
        if not upcoming:
            continue

        message = f"üü° <b>–ü—Ä–µ–¥—Å—Ç–æ—è—â–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–Ω–∞–Ω–∏–π ({department}):</b>\n\n"
        for emp in upcoming:
            next_check = emp.get_next_check_date()
            days_left = (next_check - datetime.now(pytz.utc)).days
            period_text = "1 —Ä–∞–∑ –≤ –≥–æ–¥" if emp.check_period == CHECK_PERIOD_1_YEAR else "1 —Ä–∞–∑ –≤ 3 –≥–æ–¥–∞"
            protocol_info = f"\n  <b>‚Ññ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞:</b> {emp.protocol_number}" if emp.protocol_number else ""
            message += (
                f"‚Ä¢ <b>{emp.full_name}</b> ({emp.position})\n"
                f"  –ü–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç—å: {period_text}\n"
                f"  –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ: {next_check.strftime('%d.%m.%Y')}\n"
                f"  –û—Å—Ç–∞–ª–æ—Å—å –¥–Ω–µ–π: {days_left}"
                f"{protocol_info}\n\n"
            )
        await context.bot.send_message(
            chat_id=ADMIN_CHAT_ID,
            text=message,
            parse_mode='HTML'
        )

# –û—Ç–º–µ–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏–π
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text(
        "‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.",
        reply_markup=main_keyboard
    )
    context.user_data.clear()
    return ConversationHandler.END

def setup_jobs(application):
    job_queue = application.job_queue
    job_queue.run_daily(send_overdue_notifications, time=datetime.strptime("09:00", "%H:%M").time())
    job_queue.run_daily(send_upcoming_notifications, time=datetime.strptime("09:30", "%H:%M").time())

def main() -> None:
    global ADMIN_CHAT_ID
    if os.path.exists('config.json'):
        with open('config.json', 'r') as f:
            config = json.load(f)
            ADMIN_CHAT_ID = config.get('admin_chat_id')

    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
    add_conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler('add', add_employee_start),
            MessageHandler(filters.Regex(r'^‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞$'), add_employee_start)
        ],
        states={
            GET_FULL_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_full_name)],
            GET_POSITION: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_position)],
            SELECT_DEPARTMENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, select_department)],
            GET_DEPARTMENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_department)],
            SELECT_CHECK_PERIOD: [MessageHandler(filters.TEXT & ~filters.COMMAND, select_check_period)],
            GET_CHECK_DATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_check_date)],
            GET_PROTOCOL_NUMBER: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, get_protocol_number),
                CommandHandler('skip', skip_protocol_number)
            ],
        },
        fallbacks=[
            CommandHandler('cancel', cancel),
            MessageHandler(filters.Regex(r'^‚ùå –û—Ç–º–µ–Ω–∏—Ç—å$'), cancel)
        ],
    )

    edit_conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler('edit', edit_employee_start),
            MessageHandler(filters.Regex(r'^‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ$'), edit_employee_start)
        ],
        states={
            EDIT_DEPARTMENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, select_employee_to_edit)],
            EDIT_EMPLOYEE: [MessageHandler(filters.TEXT & ~filters.COMMAND, select_edit_option)],
            EDIT_OPTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_employee_option)],
            EDIT_DATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, update_employee_date)],
            EDIT_PERIOD: [MessageHandler(filters.TEXT & ~filters.COMMAND, update_employee_period)],
        },
        fallbacks=[
            CommandHandler('cancel', cancel),
            MessageHandler(filters.Regex(r'^‚ùå –û—Ç–º–µ–Ω–∏—Ç—å$'), cancel)
        ],
    )

    delete_conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler('delete', delete_employee_start),
            MessageHandler(filters.Regex(r'^‚ùå –£–¥–∞–ª–∏—Ç—å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞$'), delete_employee_start)
        ],
        states={
            DELETE_DEPARTMENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, select_employee_to_delete)],
            DELETE_EMPLOYEE: [MessageHandler(filters.TEXT & ~filters.COMMAND, delete_employee_confirm)],
        },
        fallbacks=[
            CommandHandler('cancel', cancel),
            MessageHandler(filters.Regex(r'^‚ùå –û—Ç–º–µ–Ω–∏—Ç—å$'), cancel)
        ],
    )

    department_selection_handler = ConversationHandler(
        entry_points=[
            MessageHandler(filters.Regex(r'^üìã –°–ø–∏—Å–æ–∫ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤$'), list_employees),
            MessageHandler(filters.Regex(r'^‚ö†Ô∏è –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã—Ö$'), check_overdue),
            MessageHandler(filters.Regex(r'^üì• –≠–∫—Å–ø–æ—Ä—Ç –≤ —Ñ–∞–π–ª$'), export_data)
        ],
        states={
            'waiting_department_selection': [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_department_selection),
                MessageHandler(filters.Regex(r'^–í—Å–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è$'), handle_department_selection)
            ],
        },
        fallbacks=[
            CommandHandler('cancel', cancel),
            MessageHandler(filters.Regex(r'^‚ùå –û—Ç–º–µ–Ω–∏—Ç—å$'), cancel)
        ],
    )

    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
    application.add_handler(CommandHandler('start', start))
    application.add_handler(CommandHandler('set_admin_chat', set_admin_chat))
    application.add_handler(MessageHandler(filters.Regex(r'^üë®‚Äçüíª –ù–∞–∑–Ω–∞—á–∏—Ç—å –∞–¥–º–∏–Ω–∞$'), set_admin_chat))

    application.add_handler(add_conv_handler)
    application.add_handler(edit_conv_handler)
    application.add_handler(delete_conv_handler)
    application.add_handler(department_selection_handler)

    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–¥–∞–Ω–∏–π
    setup_jobs(application)

    # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
    application.run_polling()

if __name__ == '__main__':
    main()
